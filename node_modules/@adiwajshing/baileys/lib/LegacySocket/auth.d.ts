/// <reference types="node" />
import { ConnectionState, LegacyBaileysEventEmitter, LegacySocketConfig } from '../Types';
declare const makeAuthSocket: (config: LegacySocketConfig) => {
    state: ConnectionState;
    authInfo: import("@adiwajshing/baileys/src/Types/Legacy").LegacyAuthenticationCreds;
    ev: LegacyBaileysEventEmitter;
    canLogin: () => boolean;
    logout: () => Promise<void>;
    /** Waits for the connection to WA to reach a state */
    waitForConnectionUpdate: (check: (u: Partial<ConnectionState>) => boolean, timeoutMs?: number) => Promise<void>;
    type: "legacy";
    ws: any;
    sendAdminTest: () => Promise<string>;
    updateKeys: (info: {
        encKey: Buffer;
        macKey: Buffer;
    }) => {
        encKey: Buffer;
        macKey: Buffer;
    };
    waitForSocketOpen: () => Promise<void>;
    sendNode: ({ json, binaryTag, tag, longTag }: import("@adiwajshing/baileys/src/Types/Legacy").SocketSendMessageOptions) => Promise<string>;
    generateMessageTag: (longTag?: boolean) => string;
    waitForMessage: (tag: string, requiresPhoneConnection: boolean, timeoutMs?: number) => {
        promise: Promise<any>;
        cancelToken: () => void;
    };
    query: ({ json, timeoutMs, expect200, tag, longTag, binaryTag, requiresPhoneConnection }: import("@adiwajshing/baileys/src/Types/Legacy").SocketQueryOptions) => Promise<any>;
    setQuery: (nodes: import("@adiwajshing/baileys/src").BinaryNode[], binaryTag?: import("@adiwajshing/baileys/src/Types/Legacy").WATag, tag?: string) => Promise<{
        status: number;
    }>;
    currentEpoch: () => number;
    end: (error: Error) => void;
};
export default makeAuthSocket;
